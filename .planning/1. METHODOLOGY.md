# How We Build — AI-Assisted Development Methodology
## Updraft CCRO Dashboard

> This document explains how the Updraft CCRO Dashboard has been built using a structured,
> AI-assisted development process — covering the coding philosophy, the interview/challenge
> setup, the automated review agent system, and the continuous learning loop.
> Updated: 2026-02-27 | 264 commits · 26 completed sprints

---

## 1. The Core Idea

The dashboard is built by a single developer working with Claude (Anthropic's AI coding
assistant) as a senior engineering pair. Unlike a naive "ask AI to write code" approach,
this system is configured so that Claude **challenges, interviews, plans, and reviews** —
not just writes.

The result is a codebase that:
- Has never had a regression survive a sprint (zero across 26 sprints)
- Has a full audit trail of every architectural decision
- Improves its own process with every sprint through a structured lessons system
- Is reviewed by five specialist AI agents at each gate
- Has a continuous learning loop — every mistake becomes a permanent rule, every win becomes
  a reusable pattern

---

## 2. The Coding Philosophy — CLAUDE.md

Every instruction Claude follows is written in a file called `CLAUDE.md`, committed to the
repository root. It is loaded into Claude's context at the start of every session. It is
the single source of truth for how the codebase is built.

### 2.1 Step 0a — Decompose the Message First

> **Before anything else — before clarifying questions, before planning, before reading files —
> scan the full message for every distinct task it contains.**

When a developer sends a message with multiple requests, Claude must:
1. List every discrete request as a numbered inventory
2. Surface it back to the developer for confirmation
3. Create a task entry (`TaskCreate`) for each item
4. NOT start implementing until the inventory is confirmed

This prevents the most common AI coding failure: starting work on the most prominent
request and quietly ignoring the rest.

**Trigger words:** "also", "and", "as well", "plus", lists, mixed request types, 2+ actionable sentences

### 2.2 Step 0b — Re-surface Unanswered Questions After Compaction

Context compaction silently discards open questions. "Continue" from the user does NOT cancel
questions that were never answered. Open questions survive compaction and must be re-asked
before any work begins. This was learned from a real incident (L018) and is now a hard rule.

### 2.3 Step 0c — Understand Intent Before Any Work

> **Before writing a single line of code, ask clarifying questions if the request is ambiguous.**

Claude must NOT start work if:
- The request touches more than one area of the codebase
- The desired end-state is unclear
- A feature could be interpreted in two reasonable ways
- Something is being removed, replaced, or restructured

**How it works:** Claude proposes an interpretation first ("My reading is that you want X
on the Y page, leaving Z untouched — is that right?") and waits for confirmation.

### 2.4 The 3-Layer Review Gate

After every single deliverable, Claude must run three review layers before proceeding:

**Layer 1 — Build & Verify**
- State what was just implemented
- Verify against the acceptance criteria checklist
- Explicitly check: was anything silently removed?
- Tick completed items; flag gaps

**Layer 2 — Senior Developer Review**
- Would a staff engineer approve this?
- Are there unhandled edge cases?
- Does the code follow existing patterns (store pattern, UK spelling, Prisma adapter)?
- System integration check: does this entity exist elsewhere? Same API routes?
- Consistency check: does this introduce design drift vs existing screens?
- Design contract check: re-read relevant D-series entries in `tasks/patterns.md`

**Layer 3 — UAT/UX Review**
- What will an end user actually see?
- Is the experience better, the same, or worse?
- Are there unexpected behaviour changes?
- Have adjacent features been affected?

### 2.5 The Critical Rules

These are non-negotiable standing rules, each derived from a real incident:

| Rule | Origin | What it enforces |
|---|---|---|
| **Never delete existing features** | L001 | Every tab, panel, import, API handler must still be present after edit |
| **Bento cards must be interactive filters** | Product requirement | Every card click must filter the view below it. Read-only cards are a bug |
| **All elements must be editable and persist** | Product requirement | CCRO Team can edit everything. All edits call the API and persist to DB |
| **Flag conflicts before implementing** | Pattern | Check: (1) override risk, (2) standard conflict, (3) parallel data path |
| **Multi-task decomposition** | L006 | Surface inventory before starting. Every item tracked |
| **Never fabricate seed data** | L012 | All seed data must come from user-provided sources or have explicit approval |
| **Auth ≠ Authorisation** | L007 | Write endpoints must use `requireCCRORole()` or `checkPermission()`, never just `getUserId()` |
| **Unanswered questions survive compaction** | L018 | Re-surface open questions before any work after a compaction |
| **Position fields in create only** | L020+ | Never include ordering fields in seed upsert `update` clauses |
| **Audit all fields before migrating** | Seed rule | Before any DELETE in migration, enumerate + preserve every field |

### 2.6 Declaring Work Complete

Claude cannot say "done" until **all five** are satisfied:
1. Every PLAN.md checklist item is ticked
2. `npx next build` — zero TypeScript errors (currently: 92/92 pages, zero errors)
3. Final UAT pass described
4. Lessons written to `tasks/lessons.md`
5. PLAN.md included in commit

---

## 3. The Interview / Challenge Setup

Claude is configured to actively challenge the developer, not just execute instructions.

### 3.1 Conflict Check Before Every Feature

Before writing any code, Claude must state:
> "⚠️ Conflict check: [findings or 'None identified']"

It checks for:
1. **Override risk** — would this undo a previous deliberate implementation?
2. **Standard conflict** — inconsistency with agreed schema, API contract, or navigation pattern?
3. **Pathway conflict** — is this creating a second data path for an entity that already has one?

### 3.2 PLAN.md — Plan Before Code

Every change is written into `PLAN.md` **before touching any code**. The plan includes:
- What is changing and why
- Files to modify/create
- A checklist of acceptance criteria (`- [ ] ...`)

### 3.3 Replanning After Each Step

After each deliverable, Claude explicitly re-evaluates the plan:
- Are there newly discovered risks or complications?
- Has anything been found during implementation that should change the plan?
- Should remaining items be broken down further?

---

## 4. The Agent System

Five specialist AI sub-agents run at defined checkpoints. Each is a separate Claude instance
with a specific persona, scope, and output format. They are launched via the `Task` tool
and run independently from the main development session. Agent prompts are version-controlled
at `.claude/agents/`. Copies are in `.planning/agent-*.md`.

### 4.1 Agent Overview

```
                    ┌─────────────────────────┐
                    │   Main Claude Instance  │
                    │   (Developer's pair)    │
                    └────────────┬────────────┘
                                 │ launches
              ┌──────────────────┼──────────────────┐
              │                  │                   │
     ┌────────┴───────┐  ┌───────┴───────┐  ┌───────┴────────┐
     │   UAT Agent    │  │ Designer Agent│  │Compliance Agent│
     │  (every UI     │  │ (new screens/ │  │ (domain logic  │
     │   change)      │  │  components)  │  │   changes)     │
     └────────────────┘  └───────────────┘  └────────────────┘
              │                  │
     ┌────────┴───────┐  ┌───────┴────────────────┐
     │ Planning Agent │  │  Retrospective Agent   │
     │(sprint boundary│  │   (sprint end)         │
     │   / drift)     │  │                        │
     └────────────────┘  └────────────────────────┘
```

### 4.2 UAT Agent (`agent-uat-agent.md`)

**Persona:** Senior CRO at a UK financial firm. Uses the system daily. Has no patience for unclear,
inconsistent, or potentially embarrassing outputs.

**Criteria checked:** Clarity · Domain terminology · Trust · Missing fields · Audit trail ·
Navigation logic · Status transitions · Regulatory readiness

**Output:** PASS / CONCERN / FAIL per item. Overall verdict.
**Trigger:** After every deliverable that changes visible UI.
**Reviews run to date:** 50+

---

### 4.3 Designer Agent (`agent-designer-agent.md`)

**Persona:** Senior front-end designer. Not here to redesign — here to ensure new work is
consistent with what already exists and to flag deviations before they compound.

**Design system enforced:**
- `bento-card` CSS class for all card containers
- Brand colours: `updraft-deep`, `updraft-bar`, `updraft-bright-purple`, `updraft-light-purple`, `updraft-pale-purple`
- `font-poppins` headings · `font-inter` body
- UK British English only
- All styling via Tailwind classes — no hardcoded hex values
- Dark mode: all new components must work in both light and dark mode

**Output:** CONSISTENT / DEVIATION / IMPROVEMENT NEEDED per item. Verdict.
**Trigger:** After every new screen, component, or significant visual change.
**Reviews run to date:** 15+

---

### 4.4 Compliance Agent (`agent-compliance-agent.md`)

**Persona:** UK financial services regulatory compliance expert and former FCA examiner.
Applies FCA SYSC, SMCR, Consumer Duty, UK GDPR, ISO 31000/COSO, and the Three Lines of
Defence model.

**Criteria checked:** Audit trail completeness · Role-based access controls · Data integrity ·
SMCR accuracy · Terminology accuracy · Regulatory reporting readiness

**Output:** COMPLIANT / ADVISORY / CONCERN / NON-COMPLIANT per item. Verdict.
**Trigger:** After any change to risk, control, SMCR, obligations data model or logic.
**Reviews run to date:** 6

---

### 4.5 Planning Agent (`agent-planning-agent.md`)

**Persona:** Senior delivery manager / technical programme manager. Critical friend. Honest,
precise, focused on outcomes not effort.

**Reads:** PLAN.md · recent git log · modified files

**Criteria checked:** Sprint alignment · Checklist integrity · Implementation drift ·
Emerging complexity · Risk to remaining items

**Output:** On Track / Drift Detected (benign/harmful) / Missing from Plan / Recommended changes.
Sprint Verdict: ON TRACK / AT RISK / NEEDS REPLANNING.
**Trigger:** At sprint boundaries or if implementation feels off-track.

---

### 4.6 Retrospective Agent (`agent-retrospective-agent.md`)

**Persona:** Senior engineering lead running an end-of-sprint retrospective. Extracts
durable, actionable learning and recommends exactly where it should be baked into the
permanent process.

**Four tracks:** Mistakes & Process Failures · Wins & Reusable Patterns ·
Agent Effectiveness · Plan Quality

**Output:** Promotions recommended (with draft text) · Agent improvements ·
Plan quality improvements · Next sprint watch-outs.
**Trigger:** At sprint end.

---

### 4.7 The Tier System

| Tier | When | Agents run |
|---|---|---|
| **Tier 1** | Every deliverable that changes visible UI | Build (`npx next build`) + UAT Agent — in parallel |
| **Tier 2** | New screens or significant visual changes | Tier 1 + Designer Agent |
| **Tier 3** | Domain logic changes (risk, controls, SMCR, obligations) | Tier 1 + Compliance Agent |
| **Tier 4** | Sprint boundaries or detected drift | Planning Agent mid-sprint · Retrospective Agent at sprint end |

**Any FAIL (UAT) or NON-COMPLIANT (Compliance) finding blocks progress until resolved.**

---

## 5. The Continuous Learning System

Every sprint contributes to a self-improving process. Mistakes and wins are captured in real time
and promoted into permanent process files at sprint end.

### 5.1 The Lessons File — `tasks/lessons.md`

**L-series (Mistakes):** Root cause class · Rule to prevent recurrence · Trigger condition · Status

**W-series (Wins):** What worked and why · Whether deliberate or accidental · Reusable pattern

### 5.2 The Promotion Pipeline

```
Sprint incident → L/W entry in tasks/lessons.md
    ↓ (at sprint end)
Retrospective Agent reviews all new entries
    ↓ (agent recommends where each lesson should go)
Promotion decision:

    Process rule that always applies → CLAUDE.md
    Agent missed something → .claude/agents/NAME.md
    Architectural/domain knowledge → MEMORY.md
    Reusable implementation pattern → tasks/patterns.md
    Project-specific "never do this" → stays in lessons.md

    ↓ (after promotion)
Entry marked [PROMOTED → file] in lessons.md
Row added to Promotion Log table
```

### 5.3 Current Learning Inventory

| Series | Count | Key examples |
|---|---|---|
| L-series (active rules) | 22+ | L007 auth≠authorisation, L012 no fabricated seed data, L018 questions survive compaction |
| W-series (reusable wins) | 11+ | W001 dirty-state tracking, W003 hydration-gated defaults, W005 vertical timeline |
| Promoted to CLAUDE.md | 6+ | L001 (never delete features), L002 (intent first), L006 (decompose messages) |
| Design contract (D-series) | 27 | D001 brand colours through D027 CSS transform containing blocks |
| Implementation patterns (P-series) | 10+ | P001–P010 in tasks/patterns.md |

---

## 6. Tangible Improvements — What the System Has Caught

### 6.1 Process Improvements (promoted to CLAUDE.md)

| Lesson | What triggered it | Rule now in CLAUDE.md |
|---|---|---|
| L001 | Code silently removed tabs/imports during large file edits | "Never Delete Existing Features" rule + deletion detection checklist |
| L002 | Ambiguous request interpreted too broadly | "Understand Intent Before Any Work" — propose interpretation, confirm before coding |
| L003 | Next step started without checking if plan still made sense | "Replan after each step" — 3-layer review gate after every deliverable |
| L006 | Multi-request message — first item handled, rest ignored | "Decompose the Message First" — numbered inventory, every item tracked |
| L018 | Open questions lost to context compaction | "Step 0b — Re-surface Unanswered Questions After Compaction" |

### 6.2 Security Improvements

| Lesson | What triggered it | Rule |
|---|---|---|
| L007 | Horizon Scanning write endpoints used `getUserId()` — any authenticated user could write | Every API write endpoint must use `requireCCRORole()` or `checkPermission()` |
| L008 | `notes` field hidden in UI but returned by GET API to all callers | Role-restricted fields must be stripped at the API layer, not just hidden in UI |
| L009 | Wrong guard used — `requireCCRORole` blocked OWNER role from valid actions | Know when to use `requireCCRORole` (strictly CCRO) vs `checkPermission` (role-grantable) |

### 6.3 Data Integrity

| Lesson | What triggered it | Rule |
|---|---|---|
| L010 | CEO conflated with OWNER — different permissions | Always check the Role enum before writing any role check |
| L012 | Fabricated seed data — FCA CP26/7 title was completely wrong | Never generate seed data without express user permission |
| L013 | `for...of` on `Map` rejected by TypeScript | Always use `Array.from(map)` for Map iteration |
| D026 | Position field in seed upsert `update` clause corrupted display order on re-seed | `position` belongs in `create` only — never in `update` |

### 6.4 Reusable Patterns Captured (W-series)

| Win | Pattern | Where it applies |
|---|---|---|
| W001 | Dirty state from prop comparison — no shadow state needed | Any edit panel needing unsaved-changes detection |
| W002 | Role-scoped field filtering: fetch everything, strip before return | Any GET endpoint with role-restricted fields |
| W003 | Hydration-gated default toggle — waits for store hydration | Any list page with ownership-gated default filter |
| W004 | Silent owner filters replaced with explicit All/My toggle | Any list page with role-based filtering |
| W005 | Vertical timeline pattern for change/approval history | Any entity needing approval workflow audit trail |
| W006 | Conditional deep-dive sections appended in HTML exports | Any export with optional enrichment sections |

---

## 7. Sprint Velocity & Quality

| Sprint | Deliverables | Regressions | Build errors at merge |
|---|---|---|---|
| Foundation | All core modules | 0 | 0 |
| Database Integration | API layer + schema | 0 | 1* |
| Consumer Duty | FCA-aligned CD module | 0 | 0 |
| Actions & Workflows | Action tracking + timeline | 0 | 0 |
| Risk Register | Heatmap + register | 0 | 0 |
| Authentication | Google OAuth + NextAuth v5 | 0 | 4* |
| Controls Library | 5-phase build | 0 | 0 |
| OR & Reg Calendar | Processes + IBS + Calendar | 0 | 0 |
| Interactive HTML Export | 14-section export builder | 0 | 0 |
| Horizon Scanning | Full module | 0 | 0 |
| Relational Refactor | Junction tables + data integrity | 0 | 0 |
| Audit Remediation | 30+ audit items | 0 | 0 |
| UX Polish | Filters, defaults, navigation | 0 | 0 |
| Controls & CD Deep Polish | Graphs, timelines, exports | 0 | 0 |
| CEO Prep | Data seed + documentation | 0 | 0 |
| Dashboard Visual Uplift | 4 interactive visualisations | 0 | 0 |
| Premium Design Phase 1 | Animations, skeletons, countUp | 0 | 1* |
| Controls Section Overhaul | 9 deliverables | 0 | 0 |
| Broad Audit Sprints A/B/C | Security + panels + URL state | 0 | 0 |
| UX Foundations (Sprint E) | Back button + overflow | 0 | 0 |
| 2D Dashboard (Sprint F) | react-grid-layout | 0 | 0 |
| Dark Mode (Sprint G) | next-themes + CSS override | 0 | 0 |
| Dashboard Enhancements (Sprint H) | Tickers + scroll (in progress) | 0 | 0 |

*Build errors in early sprints were environment/config issues (Prisma stub, auth env vars,
glassmorphism revert) — none were logic bugs. All resolved in a single follow-up commit.

**Zero regressions across all 26 completed sprints.**

---

## 8. How This Differs From Standard AI Coding

| Standard approach | This approach |
|---|---|
| Ask AI to write feature → copy-paste → ship | Ask AI to plan → confirm intent → implement → 3-layer review → specialist agents → lessons |
| AI executes instructions | AI challenges scope, flags conflicts, proposes interpretations |
| Mistakes discovered in production | Mistakes caught by UAT/Designer/Compliance agents before commit |
| No institutional memory | Every lesson promoted to permanent process files |
| AI starts fresh each session | MEMORY.md + lessons.md loaded at session start — carries institutional knowledge |
| No audit of AI decisions | PLAN.md tracks every decision; git history traces every change |
| Manual QA | 5 specialist agents run automatically at each gate — parallel where possible |
| Code reviewed once | 3-layer review gate after every individual deliverable, not just at PR |

---

## 9. Files That Make This Work

| File | Purpose |
|---|---|
| `CLAUDE.md` | The "constitution" — every rule Claude follows |
| `MEMORY.md` | Persistent project knowledge across sessions |
| `PLAN.md` | Sprint-by-sprint plan with full acceptance criteria history (26 sprints) |
| `tasks/lessons.md` | Active L/W entries — reviewed every session |
| `tasks/patterns.md` | D-series design contract (D001–D027) + P-series promoted patterns |
| `.claude/agents/uat-agent.md` | UAT reviewer persona + criteria |
| `.claude/agents/designer-agent.md` | Design consistency reviewer persona + criteria |
| `.claude/agents/compliance-agent.md` | FCA compliance reviewer persona + criteria |
| `.claude/agents/planning-agent.md` | Sprint drift detector persona + criteria |
| `.claude/agents/retrospective-agent.md` | Sprint-end learning extractor persona + criteria |
| `.planning/` | Presentation pack, requirements, AWS plan, module reference, agent copies |
